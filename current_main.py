from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.utils import executor
from aiogram.dispatcher.filters import Text
import requests
import keyboards
import habits
import threading
from datetime import datetime, timedelta
from bot_options import bot, dp, headers
import aiogram.utils.markdown as md
from database_adding import add_new_user_to_users, add_user_in_db, users
from states import HabitStates, SettingsState, DeleteState
import timetable
from notificator import Notificator
import asyncio
import logging


def log(message, level):
    logging.basicConfig(filename='output.csv',
                        filemode='a',
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                        datefmt='%d-%b-%y %H:%M:%S',
                        level=logging.DEBUG)

    if level.upper() == "DEBUG":
        logging.debug(message)
    if level.upper() == "INFO":
        logging.info(message)
    if level.upper() == "WARNING":
        logging.warning(message)
    if level.upper() == "ERROR":
        logging.error(message)
    if level.upper() == "CRITICAL":
        logging.critical(message)


def read_database_users():
    log("Check code from database", "INFO")

    r = requests.get('https://faithback.herokuapp.com/api/users/', cookies=headers)
    assert r.status_code == 200
    return r.json()


database_list = read_database_users()
for db_user in database_list:
    add_new_user_to_users(db_user)


ntf = Notificator()
log("Smth to check threading", "INFO")
threading.Thread(target=ntf.start, daemon=True).start()


@dp.message_handler(commands="start")
async def start_handler(event: types.Message):
    log("Function start_handler entry", "INFO")
    user_name = event.from_user.username
    log("Check if user in database", "INFO")
    add_user_in_db(user_name, event.from_user.id)

    await event.answer(
        "–ü—Ä–∏–≤–µ—Ç, —è Octopusüêô, —É –º–µ–Ω—è –º–Ω–æ–≥–æ –ª–∞–ø–æ–∫ –∏ –∏–º–∏ –≤—Å–µ–º–∏ —è —Ö–æ—á—É —Ç–µ–±–µ –ø–æ–º–æ—á—å!\n"
        "–í–º–µ—Å—Ç–µ —Å–æ –º–Ω–æ–π —Ç—ã —Å–º–æ–∂–µ—à—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —Ä–µ–∂–∏–º –¥–Ω—è "
        "–∏ –Ω–µ –∑–∞–±—ã–≤–∞—Ç—å –æ –≤–∞–∂–Ω—ã—Ö —Å–æ–±—ã—Ç–∏—è—Ö\n–°–ø–µ—Ä–≤–∞ –Ω–∞—Å—Ç—Ä–æ–π –≤—Ä–µ–º—è, –Ω–∞–∂–∞–≤ –ù–∞—Å—Ç—Ä–æ–π–∫–∏",
        reply_markup=keyboards.get_main_menu_keyboard()
    )


@dp.message_handler(Text(equals="–ù–∞—Å—Ç—Ä–æ–π–∫–∏"))
async def settings_handler(event: types.Message):
    log("Function settings_handler entry", "INFO")
    user_name = event.from_user.username
    log("Check if user in database", "INFO")
    add_user_in_db(user_name, event.from_user.id)

    await SettingsState.call_time.set()

    await event.reply(
        "–ß—Ç–æ–±—ã –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å —Ç–µ–±–µ –æ –¥–µ–ª–∞—Ö –≤–æ–≤—Ä–µ–º—è –º–Ω–µ –Ω—É–∂–Ω–æ "
        "–∑–Ω–∞—Ç—å —Ç–≤–æ–π —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å, –Ω–∞–ø–∏—à–∏ –µ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ +/-**:** UTC",
        reply_markup=keyboards.get_temporary_keyboard()
    )


@dp.message_handler(state=SettingsState.call_time)
async def process_settings_time(event: types.Message, state: FSMContext):
    log("Function process_settings_time entry", "INFO")
    if event.text == "–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é":
        await state.finish()
        log("Bot sends message", "INFO")
        await event.answer(
            "–í—ã—Ö–æ–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é!",
            reply_markup=keyboards.get_main_menu_keyboard()
        )
        return
    log("Check if user in database", "INFO")
    requests.post(
        'https://faithback.herokuapp.com/api/users/{}/'.format(event.from_user.username), json={
            "time_shift": event.text,
        },
        cookies=headers
    )

    await state.finish()
    log("Bot sends message", "INFO")
    await event.answer(
        "–ó–∞–ø–æ–º–Ω–∏–ª!",
        reply_markup=keyboards.get_main_menu_keyboard()
    )


@dp.message_handler(Text(equals="–î–æ–±–∞–≤–∏—Ç—å"))
async def add_habit_handler(event: types.Message):
    log("Function add_habit_handler entry", "INFO")
    user_name = event.from_user.username

    add_user_in_db(user_name, event.from_user.id)

    await HabitStates.name.set()
    log("Bot sends message", "INFO")
    await event.reply(
        "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–∏–≤—ã—á–∫–∏",
        reply_markup=keyboards.get_temporary_keyboard()
    )


@dp.message_handler(state=HabitStates.name)
async def process_habit_name(event: types.Message, state: FSMContext):
    log("Function process_habit_name entry", "INFO")
    if event.text == "–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é":
        await state.finish()
        log("Bot sends message", "INFO")
        await event.answer(
            "–í—ã—Ö–æ–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é!",
            reply_markup=keyboards.get_main_menu_keyboard()
        )
        return

    async with state.proxy() as data:
        data['name'] = event.text
    log("Bot sends message", "INFO")
    await event.answer(
        "–í–≤–µ–¥–∏, —á—Ç–æ –º–Ω–µ –ø—Ä–∏—Å–ª–∞—Ç—å —Ç–µ–±–µ, –∫–æ–≥–¥–∞ –ø—Ä–∏–¥—ë—Ç –≤—Ä–µ–º—è",
        reply_markup=keyboards.get_temporary_keyboard()
    )

    await HabitStates.next()


@dp.message_handler(state=HabitStates.text)
async def process_habit_text(event: types.Message, state: FSMContext):
    log("Function process_habit_text entry", "INFO")
    if event.text == "–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é":
        await state.finish()
        log("Bot sends message", "INFO")
        await event.answer(
            "–í—ã—Ö–æ–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é!",
            reply_markup=keyboards.get_main_menu_keyboard()
        )
        return

    async with state.proxy() as data:
        data['text'] = event.text
    log("Bot sends message", "INFO")
    await event.answer(
        "–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è, –∫–æ–≥–¥–∞ —Ç—ã —Ö–æ—á–µ—à—å, —á—Ç–æ–±—ã —è —Ç–µ–±–µ –Ω–∞–ø–æ–º–Ω–∏–ª\n"
        "–ï—Å–ª–∏ —Ç—ã —Ö–æ—á–µ—à—å, —á—Ç–æ–±—ã –Ω–∞–ø–æ–º–∏–Ω–∞–ª–∫–∞ –ø–æ–≤—Ç–æ—Ä—è–ª–∞—Å—å, –≤–≤–µ–¥–∏ –±–ª–∏–∂–∞–π—à—É—é –¥–∞—Ç—É, –∫–æ–≥–¥–∞ –º–Ω–µ –Ω–∞–¥–æ –Ω–∞–ø–æ–º–Ω–∏—Ç—å\n"
        "–§–æ—Ä–º–∞—Ç: Jun 1 2005 1:33PM",
        reply_markup=keyboards.get_temporary_keyboard()
    )

    await HabitStates.next()


@dp.message_handler(state=HabitStates.call_time)
async def process_habit_call_time(event: types.Message, state: FSMContext):
    log("Function process_habit_call_time entry", "INFO")
    if event.text == "–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é":
        await state.finish()
        log("Bot sends message", "INFO")
        await event.answer(
            "–í—ã—Ö–æ–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é!",
            reply_markup=keyboards.get_main_menu_keyboard()
        )
        return

    try:
        datetime.strptime(event.text, '%b %d %Y %I:%M%p')
    except ValueError:
        log("Bot sends message", "INFO")
        await bot.send_message(chat_id=event.from_user.id, text="–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –¥–∞—Ç—É –≤ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ.")
        return

    async with state.proxy() as data:
        data['call_time'] = event.text
    log("Bot sends message", "INFO")
    await event.answer(
        "–•–æ—á–µ—à—å —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ —Å–æ–±—ã—Ç–∏–µ —Ä–µ–≥—É–ª—è—Ä–Ω—ã–º?",
        reply_markup=keyboards.get_call_delay_keyboard()
    )

    await HabitStates.next()


@dp.message_handler(state=HabitStates.call_delay)
async def process_habit_name(event: types.Message, state: FSMContext):
    log("Function process_habit_name entry", "INFO")
    if event.text == "–ù–µ—Ç":
        # –ù–∞–º –Ω–µ –Ω—É–∂–Ω–∞ —Ä–µ–≥—É–ª—è—Ä–Ω–æ—Å—Ç—å, –æ–¥–∏–Ω —Ä–∞–∑ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è.
        async with state.proxy() as data:
            new_habit = habits.Habit(
                habits.HabitOptions(
                    name=data['name'],
                    text=data['text'],
                    call_time=datetime.strptime(data['call_time'], '%b %d %Y %I:%M%p'),
                    call_delay=timedelta(),
                    user=users[event.from_user.id]
                )
            )

            users[event.from_user.id].add_habits("habits", [new_habit])
            log("Check code from database", "INFO")
            requests.post(
                'https://faithback.herokuapp.com/api/users/{}/clusters/habits/'.format(event.from_user.username), json={
                    "name": new_habit.options_.name,
                    "text": new_habit.options_.text,
                    "call_time": str(new_habit.options_.call_time),
                    "call_delay": str(new_habit.options_.call_delay),
                },
                cookies=headers
            )

            temp = "–î–æ–±–∞–≤–∏–ª –ø—Ä–∏–≤—ã—á–∫—É:\n" + \
                   "–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–∏–≤—ã—á–∫–∏: {}\n".format(md.bold(data['name'])) + \
                   "–ë—É–¥—É –ø–∏—Å–∞—Ç—å —Ç–µ–±–µ: {}\n".format(data['text']) + \
                   "–ë–ª–∏–∂–∞–π—à–µ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: {}\n".format(data['call_time'])

            await state.finish()
            log("Bot sends message", "INFO")
            await event.answer(
                temp,
                reply_markup=keyboards.get_main_menu_keyboard()
            )
        return
    log("Bot sends message", "INFO")
    await event.answer(
        "–ö–∞–∫ —á–∞—Å—Ç–æ –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å?",
        reply_markup=keyboards.get_call_delay_pick_keyboard()
    )

    await HabitStates.next()


@dp.message_handler(state=HabitStates.call_delay_pick)
async def process_habit_call_delay_pick(event: types.Message, state: FSMContext):
    log("Function process_habit_call_delay_pick entry", "INFO")
    async with state.proxy() as data:
        if event.text == "–ö–∞–∂–¥—ã–π –¥–µ–Ω—å":
            new_habit = habits.Habit(
                habits.HabitOptions(
                    name=data['name'],
                    text=data['text'],
                    call_time=datetime.strptime(data['call_time'], '%b %d %Y %I:%M%p'),
                    call_delay=timedelta(days=1),
                    user=users[event.from_user.id]
                )
            )

        if event.text == "–ö–∞–∂–¥—É—é –Ω–µ–¥–µ–ª—é":
            new_habit = habits.Habit(
                habits.HabitOptions(
                    name=data['name'],
                    text=data['text'],
                    call_time=datetime.strptime(data['call_time'], '%b %d %Y %I:%M%p'),
                    call_delay=timedelta(weeks=1),
                    user=users[event.from_user.id]
                )
            )

        users[event.from_user.id].add_habits("habits", [new_habit])
        log("Check code from database", "INFO")
        requests.post(
            'https://faithback.herokuapp.com/api/users/{}/clusters/habits/'.format(event.from_user.username), json={
                "name": new_habit.options_.name,
                "text": new_habit.options_.text,
                "call_time": str(new_habit.options_.call_time),
                "call_delay": str(new_habit.options_.call_delay),
            },
            cookies=headers
        )

        temp = "–î–æ–±–∞–≤–∏–ª –ø—Ä–∏–≤—ã—á–∫—É:\n" + \
               "–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–∏–≤—ã—á–∫–∏: {}\n".format(md.bold(data['name'])) + \
               "–ë—É–¥—É –ø–∏—Å–∞—Ç—å —Ç–µ–±–µ: {}\n".format(data['text']) + \
               "–ë–ª–∏–∂–∞–π—à–µ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: {}\n".format(data['call_time']) + \
               "–ß–∞—Å—Ç–æ—Ç–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è: {}".format(event.text)
        log("Bot sends message", "INFO")
        await event.answer(
            temp,
            reply_markup=keyboards.get_main_menu_keyboard()
        )
    await state.finish()


@dp.message_handler(Text(equals="–£–¥–∞–ª–∏—Ç—å"))
async def remove_habit_handler(event: types.Message):
    log("Function remove_habit_handler entry", "INFO")
    log("Check code from database", "INFO")
    r = requests.get(
        'https://faithback.herokuapp.com/api/users/{}/'.format(event.from_user.username),
        cookies=headers
    )

    if len(r.json()['habit_clusters'][0]['habits']) == 0:
        log("Bot sends message", "INFO")
        await bot.send_message(chat_id=event.from_user.id, text="–î–ª—è –Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å –ø—Ä–∏–≤—ã—á–∫—É. –°–ø–∏—Å–æ–∫ –ø—Ä–∏–≤—ã—á–µ–∫ –ø—É—Å—Ç!")
        return

    cnt = 1
    send_habits = ""

    for habit in r.json()['habit_clusters'][0]['habits']:
        send_habits += str(cnt) + ") " + habit['name'] + "\n"
        cnt += 1

    await DeleteState.delete_habit.set()
    log("Bot sends message", "INFO")
    await event.reply(
        "–Ø –ø—Ä–æ–Ω—É–º–µ—Ä–æ–≤–∞–ª —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ç–≤–æ–∏—Ö —Å–æ–±—ã—Ç–∏–π, –æ—Ç–ø—Ä–∞–≤—å –Ω–æ–º–µ—Ä —Ç–æ–≥–æ, –∫–æ—Ç–æ—Ä–æ–µ –Ω–∞–¥–æ —É–¥–∞–ª–∏—Ç—å:\n" + send_habits,
        reply_markup=keyboards.get_temporary_keyboard()
    )
    log("Check code from database", "INFO")
    r = requests.get(
        'https://faithback.herokuapp.com/api/users/{}/'.format(event.from_user.username),
        cookies=headers
    )


@dp.message_handler(state=DeleteState.delete_habit)
async def delete_habit(event: types.Message, state: FSMContext):
    log("Function delete_habit entry", "INFO")

    if event.text == "–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é":
        await state.finish()
        log("Bot sends message", "INFO")
        await event.answer(
            "–í—ã—Ö–æ–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é!",
            reply_markup=keyboards.get_main_menu_keyboard()
        )
        return
    log("Check code from database", "INFO")
    r = requests.get(
        'https://faithback.herokuapp.com/api/users/{}/'.format(event.from_user.username),
        cookies=headers
    )

    allowed = {str(i + 1) for i in range(len(r.json()['habit_clusters'][0]['habits']))}

    if event.text not in allowed:
        log("Bot sends message", "INFO")
        await bot.send_message(chat_id=event.from_user.id, text="–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ!")
        return

    url = 'https://faithback.herokuapp.com/api/habbit/{}'
    log("Check code from database", "INFO")
    requests.delete(
        url.format(r.json()['habit_clusters'][0]['habits'][int(event.text) - 1]['id']),
        cookies=headers
    )
    log("Bot sends message", "INFO")
    await event.answer(
        "–ì–æ—Ç–æ–≤–æ!",
        reply_markup=keyboards.get_main_menu_keyboard()
    )

    await state.finish()


@dp.message_handler(Text(equals="–†–µ–∂–∏–º"))
async def mode_handler(event: types.Message):
    log("Function mode_handler entry", "INFO")
    new_tt = timetable.TimeTable(event.from_user.username)
    tt = await new_tt.get_week_timetable()

    text_to_send = ""

    for day, names in tt.items():
        text_to_send += day + ": " + "".join((e + ", ") for e in names)
        text_to_send = text_to_send[:-2] + "\n"
    log("Bot sends message", "INFO")
    await bot.send_message(chat_id=event.from_user.id, text=text_to_send)


if __name__ == '__main__':
    executor.start_polling(dp)
